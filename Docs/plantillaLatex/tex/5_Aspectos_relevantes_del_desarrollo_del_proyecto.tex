\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}


\section{Descripción del juego}

Para entender todo el proceso de entrenamiento del bot inteligente que voy a implementar considero necesario entender el funcionamiento y reglas del juego así como ciertas particularidades relacionadas con la captura y uso de datos.

El juego va a ser un "mata-marcianos" de tipo arcade, un juego infinito en el que el jugador aspira a alcanzar la máxima puntuación de forma individual. Este tipo de juegos era típico de los salones recreativos y centros comerciales. En este caso nos ponemos a los mando de una nave espacial que a de evitar que los enemigos invasores traspasen la zona inferior de la pantalla (nuestro territorio). Los enemigos aparecen en oleadas y se limitan a avanzar oscilando hacia su objetivo. El jugador ha de eliminar el máximo numero de enemigos posibles sin impactar contra ellos. Cuanto menos se acerquen a la zona inferior de la pantalla mayor será la puntuación que otorgue su eliminación. Si los enemigos llegan a nuestro territorio restarán una cantidad fija de puntos, por lo que nuestra puntuación final se verá notablemente mermada.

En este punto se decidió establecer unas reglas un poco mas "especiales" para simplificar el proceso. En primer lugar, los enemigos no atacan al jugador con ningún tipo de proyectil, se limitan a avanzar oscilando a una velocidad constante. Por otro lado, se limitará el número de enemigos visibles simultáneamente en la pantalla con el fin de poder hacen una instancia de tamaño constante y no perder enemigos en la captura de datos. Para darle un podo de dinamismo y evitar que el jugador deje pulsada la tecla de disparo infinitamente, se ha implementado un sistema de calentamiento del arma. Este sistema hace que los disparos consecutivos calienten el arma y si no se dispara, se enfríe lentamente. Si el arma llega al máximo de temperatura dejará de disparar. El sistema de calentamiento del arma dio lugar a la idea de implementar uno "power-up" o potenciadores. Estos serán de dos tipos, uno enfría de golpe el arma una determinada cantidad y otro duplica en numero de balas disparadas simultáneamente. Esto, como se describirá mas adelante, condicionará la estructura de las instancias.

Como última aclaración los "sujetos de prueba", a los que el Bot deberá imitar, se aburrían jugándolo, por lo que se introdujo un Jefe que tendría una enorme cantidad de vida. Este Jefe aparecerá una vez por minuto jugado y restará muchos más puntos que los enemigos estándar. La eliminación de este tipo de enemigo conlleva un gran calentamiento del arma y, por tanto, un estrés añadido al jugador, que tendrá estar listo en todo momento para es tipo de combate.


\section{Comunicación entre scripts}

\subsection{introducción}
Para el desarrollo del proyecto se han utilizado los lenguajes de programación. Por un lado c#, que ha sido el lenguaje más utilizado durante años para el desarrollo de videojuegos, por otro, python, que es el lenguaje en el que están las librerías utilizadas para el entrenamiento de nuestra red neuronal. Por este motivo, era necesario encontrar la forma de que el juego pudiera ejecutar los scripts de python, además de pasarle la correspondiente información. El proceso de comunicación ha sido uno de los puntos que mas problemas me ha dado a lo largo del desarrollo del proyecto, ya que hubo que probar varias alternativas hasta dar con la correcta.

\subsection{Pythonet}
En primer lugar estudié la posibilidad de integrar python en c#, de tal forma que pudiese ejecutar pequeños scripts de python dentro de mi código en c#. Para esta integración se probé a utilizar pythonet. Pythonet, como pone en su pagina web, permitiría a python interactuar con el CLR de .net e incrustar código python en .net. Tras numerosas pruebas no hubo forma de ejecutar una sola línea de python desde un script monobehaviour.

\subsection{IronPython}
La siguiente herramienta con la que se estuvo trabajando fue IronPython. IronPython prometía unas utilidades muy similares a Pythonet, o incluso mejores, pero tras varias horas de lectura de la documentación encuentro algo que tira por tierra mis expectativas, Ironpython aun no es compatible al cien por cien con Scikit-learn.

\subsection{Pipes o tuberías}
Comienza una nuevas vía de investigación, era el turno de los pipes (o tuberías) de python. En internet no había demasiada información y la poca que había no era muy clara, pero aún así me puse manos a la obra y a las pocas horas ya tenía dos scripts de python comunicándose entre ellos. Bien, ahora solo quedaba que se comunicase con mi aplicación en .net. Este ultimo paso no hubo forma de llevarlo a cabo, no conseguí que ambas aplicaciones intercambiasen mensajes de forma correcta.

\subsection{Sockets}
Finalmente me decanté por utilizar, o bien WebServices, o bien sockets.Como la opción de los sockets me parecía en principio mas sencilla me puse manos a la obra. Primero hice un servidor de sockets y un cliente en python, y funcionó. El script era sencillo, un simple eco, cuando alguien se conectaba enviaba de vuelta toda la información que recibiese. El siguiente pasó lógico era hacer lo propio en .net, y funcionó, ya tenía las aplicaciones intercambiando mensajes.

El funcionamiento final consiste en un script de python que al ejecutarse abre un socket anónimo que se queda a la espera de una conexión, cuando alguien se conecta empieza a escuchar y procesar todos los mensajes que le llegan pasándoselos a la red neuronal, una vez procesados, por la misma vía responde con el resultado calculado.


\section{Definiendo las instancias}

Para dotar a la máquina de la capacidad de aprender es necesario, como en el aprendizaje de los seres humanos, una serie de estímulos. Estos estímulos, en mi caso, se traducen en una serie de estados o instancias.

Para empezar se comenzó seleccionando los que parecían mas relevantes, como la posición absoluta del jugador y la posición absoluta de los enemigos  en el campo de batalla. Solo formaba parte de la clase la última tecla pulsada por el usuario, que podía ser Arriba,Abajo,Izquierda, Derecha, Disparo o No disparo.

Para entrenar una red neuronal en número de atributos de entrada debe ser inmutable, por lo que se estableció un máximo de cuatro enemigos en pantalla de forma simultánea. Dado que yo estaba programando el videojuego yo tenía el control absoluto de todas las variables.

\imagen{tabla1-estados1}{Primera versión Instancia}

Tras un primer entrenamiento, con un numero no no alto de instancias (~4000) los resultados no eran muy satisfactorios. En siguiente iteración se observó que había otro parámetro más que nos podría ayudar a tomar decisiones, la vida del enemigo.

\imagen{tabla2-estados2}{Segunda versión Instancia}

